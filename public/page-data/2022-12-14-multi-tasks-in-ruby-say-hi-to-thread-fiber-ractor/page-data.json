{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-12-14-multi-tasks-in-ruby-say-hi-to-thread-fiber-ractor/","result":{"data":{"site":{"siteMetadata":{"title":"Jackie's Blog"}},"markdownRemark":{"id":"65803d60-a7de-5ead-ad26-074b28c70b17","excerpt":"I. Giới thiệu về đa tác vụ - đa nhiệm trong Ruby II. Multithreading với Thread 1. Tạo và tương tác với thread a. Tạo thread b. Tương tác với Thread 2. Sử dụng…","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#i-gi%E1%BB%9Bi-thi%E1%BB%87u-v%E1%BB%81-%C4%91a-t%C3%A1c-v%E1%BB%A5---%C4%91a-nhi%E1%BB%87m-trong-ruby\">I. Giới thiệu về đa tác vụ - đa nhiệm trong Ruby</a></p>\n</li>\n<li>\n<p><a href=\"#ii-multithreading-v%E1%BB%9Bi-thread\">II. Multithreading với Thread</a></p>\n<ul>\n<li>\n<p><a href=\"#1-t%E1%BA%A1o-v%C3%A0-t%C6%B0%C6%A1ng-t%C3%A1c-v%E1%BB%9Bi-thread\">1. Tạo và tương tác với thread</a></p>\n<ul>\n<li><a href=\"#a-t%E1%BA%A1o-thread\">a. Tạo thread</a></li>\n<li><a href=\"#b-t%C6%B0%C6%A1ng-t%C3%A1c-v%E1%BB%9Bi-thread\">b. Tương tác với Thread</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-s%E1%BB%AD-d%E1%BB%A5ng-variables-trong-thread\">2. Sử dụng variables trong thread</a></p>\n</li>\n<li>\n<p><a href=\"#3-exception-trong-thread\">3. Exception trong thread</a></p>\n</li>\n<li>\n<p><a href=\"#4-ki%E1%BB%83m-so%C3%A1t-thread\">4. Kiểm soát thread</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#iii-l%C3%A0m-vi%E1%BB%87c-%E1%BB%9F-c%E1%BA%A5p-%C4%91%E1%BB%99-process\">III. Làm việc ở cấp độ Process</a></p>\n<ul>\n<li><a href=\"#1-sinh-ra-m%E1%BB%99t-process-m%E1%BB%9Bi\">1. Sinh ra một process mới</a></li>\n<li><a href=\"#2-process-con-ch%E1%BA%A1y-%C4%91%E1%BB%99c-l%E1%BA%ADp\">2. Process con chạy độc lập</a></li>\n<li><a href=\"#3-block-code-v%C3%A0-subprocesses\">3. Block code và Subprocesses</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#iv-fiber-l%C3%A0-m%E1%BB%99t-lightweight-thread\">IV. Fiber là một lightweight thread?</a></p>\n</li>\n<li>\n<p><a href=\"#v-hi%E1%BB%83u-v%E1%BB%81-ractor\">V. Hiểu về Ractor</a></p>\n<ul>\n<li><a href=\"#1-c%C3%A1ch-ractor-ho%E1%BA%A1t-%C4%91%E1%BB%99ng\">1. Cách Ractor hoạt động</a></li>\n<li><a href=\"#2-truy%E1%BB%81n-variable-v%C3%A0o-ractor\">2. Truyền Variable vào Ractor</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"i-giới-thiệu-về-đa-tác-vụ---đa-nhiệm-trong-ruby\" style=\"position:relative;\"><a href=\"#i-gi%E1%BB%9Bi-thi%E1%BB%87u-v%E1%BB%81-%C4%91a-t%C3%A1c-v%E1%BB%A5---%C4%91a-nhi%E1%BB%87m-trong-ruby\" aria-label=\"i giới thiệu về đa tác vụ   đa nhiệm trong ruby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>I. Giới thiệu về đa tác vụ - đa nhiệm trong Ruby</h2>\n<p>Việc làm nhiều việc cùng lúc luôn luôn là một điều hữu ích. Trong lập trình, multitasking thường ám chỉ đến việc khi chương trình đang thực hiện task A thì thay vì phải đợi task A làm xong (ví dụ như các task gọi API, tương tác với database, IO …) thì ta có thể chuyển qua làm task B trong khi chờ đợi task A xong. Có thể thực hiện multitask thì cũng có nghĩa computer có nhiều hơn 1 CPU, chương trình có thể chia các task vào các CPU khác nhau.</p>\n<p>Tuy nhiên việc lập trình để làm đa tác vụ trong cùng lúc cũng khá phức tạp. Task B có thể thay đổi data, resource mà task A đang làm việc trên đó (hoặc ngược lại) dẫn đến xung đột và kết quả cuối cùng không còn chính xác. Ta nên cẩn trọng và tính toán cụ thể khi lập trình multitasking.</p>\n<p>Khi một chương trình làm nhiều thứ cùng lúc, mỗi “thứ” khác nhau là một <em><strong>thread</strong></em> và phải đảm báo những “thread” này chạy chính xác, không ảnh hưởng đến nhau bất kể thứ tự trước sau ta gọi đó là <em><strong>thread safety</strong></em>. Nếu 2 threads chạy ảnh hưởng lên nhau (ví dụ 2 threads cùng viết vào 1 text file, thread cuối cùng overwrite thread trước) đây được gọi là <em><strong>race condition</strong></em> và ta luôn tránh trường hợp này xảy ra trong multitasking.</p>\n<p>Điều cốt yếu để đạt được <em><strong>thread safety</strong></em> là tránh việc data/state được chia sẽ giữa các threads, đặc biệt là khi data/state được thay đổi bởi một thread mà những thread khác không biết được. Trong trường hợp bắt buộc phải chia sẽ data/state thì ta nên có các biện pháp hạn chế, cấu trúc phù hợp để chỉ có 1 thread được truy cập tại một thời điểm.</p>\n<p>Trước kia, các chương trình Ruby dùng GIL (Global Interpreter Lock), thứ này đảm bảo chỉ có 1 thread (ở cấp độ hệ điều hành, ta cần phân biệt rõ thread ở cấp hệ điều hành và thread ở cấp logic/abstraction) có để được chạy tại bất kỳ thời điểm nào, nhưng từ Ruby 3.1 có một cấu trúc mới cho phép chúng ta chạy nhiều threads (ở cấp độ hệ điều hành) gọi là <strong>Ractors</strong>, chúng ta sẽ tìm hiểu thêm ở phần sau.</p>\n<p>GIL giúp Ruby đạt được một số ưu điểm:</p>\n<ul>\n<li>Thread safety - Chỉ có 1 thread hoạt động tại một thời điểm</li>\n<li>Khi một thread bị block thì thread khác sẽ hoạt động</li>\n</ul>\n<p>Nhưng nó cũng có nhược điểm là:</p>\n<ul>\n<li>Không thể thực hiện multiple parallel CPUs với một Ruby interpreter đơn lẻ (nếu ko sử dụng <strong>Ractor</strong>)</li>\n</ul>\n<p>==========</p>\n<p>Trong bài hôm nay chúng ta sẽ tìm hiểu về cách Ruby Thread Abstraction (<strong>Thread</strong> ở cấp độ ngôn ngữ, ko phải cấp hệ điều hành) cho phép chúng ta chạy nhiều thứ khác nhau và có vẻ như chúng sẽ được chạy trong “cùng thời điểm”. Ta cũng biết cách để tạo ra các process (cấp hệ điều hành).</p>\n<p>Một loại “thread abstraction” khác nữa là <strong>Fibers</strong> giúp ta tạm dừng một phần chương trình để chạy phần khác của chương trình.</p>\n<p>Cuối cùng là <strong>Ractors</strong> cho phép chúng ta lách qua GIL và có “multithreading thực sự” với Ruby (multitasking trên multiple CPUS).</p>\n<h2 id=\"ii-multithreading-với-thread\" style=\"position:relative;\"><a href=\"#ii-multithreading-v%E1%BB%9Bi-thread\" aria-label=\"ii multithreading với thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>II. Multithreading với Thread</h2>\n<p>Level thấp nhất trong Ruby để làm hai việc cùng lúc là sử dụng <strong>Thread</strong> class.</p>\n<p>Mặc dù threads có thể tận dụng multiple processors/cores (về mặt lý thuyết) trong một CPU, nhưng có một điểm cần lưu ý chính. Nhiều Ruby extension libraries không đảm bảo “thread safe”, bởi vì chúng mong đợi GIL sẽ đảm nhiệm bảo đảm “thread safe” cho chúng. Vậy nên, Ruby <strong>có</strong> sử dụng native operating system threads (threads ở cấp hệ điều hành) nhưng chỉ vận hành 1 thread tại 1 thời điểm.</p>\n<p>Trừ khi sử dụng Ractor library, nếu không chúng ta sẽ không bao giờ thấy 2 threads trong cùng app chạy “đồng thời thực sự”. Kịch bản phổ biến nhất sẽ là 1 thread bận rộn xử lý Ruby code trong khi 1 thread khác đợi các tác vụ I/O.</p>\n<h3 id=\"1-tạo-và-tương-tác-với-thread\" style=\"position:relative;\"><a href=\"#1-t%E1%BA%A1o-v%C3%A0-t%C6%B0%C6%A1ng-t%C3%A1c-v%E1%BB%9Bi-thread\" aria-label=\"1 tạo và tương tác với thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Tạo và tương tác với thread</h3>\n<h4 id=\"a-tạo-thread\" style=\"position:relative;\"><a href=\"#a-t%E1%BA%A1o-thread\" aria-label=\"a tạo thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>a. Tạo thread</h4>\n<p>Dưới đây là một ví dụ đơn giản về việc download các trang webs một cách song song (parallel). Việc download mỗi trang web sẽ được 1 thread riêng lo liệu.</p>\n<blockquote>\n<p>Code:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string-literal\"><span class=\"token string\">\"net/http\"</span></span>\npages <span class=\"token operator\">=</span> <span class=\"token string-literal\"><span class=\"token string\">%w[www.rubycentral.org www.pragprog.com www.google.com]</span></span>\nthreads <span class=\"token operator\">=</span> pages<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>page_to_fetch<span class=\"token operator\">|</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>page_to_fetch<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>url<span class=\"token operator\">|</span>\n    http <span class=\"token operator\">=</span> Net<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">HTTP</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token number\">80</span><span class=\"token punctuation\">)</span>\n    print <span class=\"token string-literal\"><span class=\"token string\">\"Fetching: </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">url</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\\n\"</span></span>\n    response <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"/\"</span></span><span class=\"token punctuation\">)</span>\n    print <span class=\"token string-literal\"><span class=\"token string\">\"Got </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">url</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">response<span class=\"token punctuation\">.</span>message</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\\n\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>thread<span class=\"token operator\">|</span> thread<span class=\"token punctuation\">.</span>join <span class=\"token punctuation\">}</span>\nprint <span class=\"token string-literal\"><span class=\"token string\">\"We're done here!\"</span></span></code></pre></div>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Fetching: www.rubycentral.org\nFetching: www.pragprog.com\nFetching: www.google.com\nGot www.google.com: OK\nGot www.pragprog.com: Moved Permanently\nGot www.rubycentral.org: OK\nWe're done here</code></pre></div>\n<p>Như các bạn thấy các new threads được tạo bằng cách gọi <code class=\"language-text\">Thread.new</code>.</p>\n<p><code class=\"language-text\">Thread.new</code> sẽ nhận 1 <strong>block</strong> chứa code để được chạy trong thread mới. Trong ví dụ trên thì block sử dụng thư viện net/http để fetch trang web dựa trên URL được pass vào thread.</p>\n<p>Một khi thread được tạo, nó sẽ được xếp lịch để thực thi bởi hệ điều hành, và trong ví dụ này, chúng ta không có quyền kiểm soát khi nào thread sẽ chạy.</p>\n<p>Trong đoạn code này, chúng ta sử dụng <code class=\"language-text\">map</code> để tạo 3 threads mới và lưu vào một array. <code class=\"language-text\">Threads</code>, như mọi thứ khác trong Ruby đều là objects vậy nên ta có thể assign vào variable, return từ block/method và truyền như một parameter.</p>\n<p>Bây giờ hãy nhìn kỹ hơn cách các threads hoạt động:</p>\n<ul>\n<li>Chúng ta fetch 3 trang web bằng 3 threads khác nhau, nhìn kỹ output ta sẽ thấy 3 “Fetch” sẽ chạy trước bất cứ “Got” nào. Tại sao 3 “Fetch” lại được in ra trước sẽ được giải thích ở bên dưới.</li>\n<li>ở chương trình chính khi thread đầu tiên được tạo ra, được lên lịch để thực thi, khi thực thi nó sẽ gọi HTTP request và bị block trong khi chờ response khi gọi HTTP request -> khi bị xác nhận là block (hệ điều hành/GIL tự xác định) thì sẽ quay lại chương trình chính và ngay lập tực tạo tiếp thread mới và cứ tiếp tục.</li>\n<li>Việc tạo ra thread sẽ nhanh hơn rất rất nhiều so với việc đợi response từ một HTTP request nên dẫn đến cả 3 threads này được tạo xong thì thread đầu tiên được tạo vẫn chưa nhận được response => 3 “Fetch” được in ra trước 3 “Got”</li>\n</ul>\n<p>Trong ví dụ code trên chúng ta tạo thread và truyền URL như là một parameter vào block, tại sao chúng ta lại truyền URL vào trong khi chúng ta đã có biến <code class=\"language-text\">page_to_fetch</code> ở bên ngoài block ? Câu trả lời liên quan tới “thread safety” và cách các threads chia sẽ values.</p>\n<p>Một thread chia sẽ tất cả global/instance/local variables đã tồn tại và available tại thời điểm thread được tạo. Nhưng việc chia sẽ không phải lúc nào cũng tốt. Trong ví dụ của chúng ta, <code class=\"language-text\">page_to_fetch</code> variable được chia sẽ tới 3 threads</p>\n<ul>\n<li>Đối với thread đầu, ban đầu <code class=\"language-text\">page_to_fetch</code> sẽ bằng ”<a href=\"http://www.rubycentral.org\">www.rubycentral.org</a>” nhưng vòng loop vấn tiếp tục chạy</li>\n<li>Ở loop thứ 2 <code class=\"language-text\">page_to_fetch</code> được cập nhật thành “pragprog.com”, lúc này có thể thread đầu vẫn chưa hoàn tất việc sử dụng biến <code class=\"language-text\">page_to_fetch</code> và nếu nó sử dụng thì nó sẽ sử dụng giá trị mới. Những lỗi kiểu này bắt buộc phải tránh vì rất khó để tìm ra.</li>\n<li>Vậy nên việc sử dụng local variables được tạo ở mỗi thread sẽ đảm bảo “thread safety” hơn, bằng cách pass value trực vào block và sử dụng để tạo biến local ở mỗi thread.</li>\n</ul>\n<h4 id=\"b-tương-tác-với-thread\" style=\"position:relative;\"><a href=\"#b-t%C6%B0%C6%A1ng-t%C3%A1c-v%E1%BB%9Bi-thread\" aria-label=\"b tương tác với thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>b. Tương tác với Thread</h4>\n<p>Thông thường khi một Ruby program bị terminate (process tương ứng bị terminate), tất cả các threads đều bị kill, bất kể state của các threads này là gì. Nếu chúng ta không có logic để handle phần này thì dễ có tình trạng khi Ruby program kết thúc khi 1 hoặc nhiều threads vẫn còn đang xử lý và phần xử lý này sẽ không bao giờ hoàn tất.</p>\n<p>Tất nhiên cũng ta có thể đợi 1 Ruby thread nào đó cho đến khi nó hoàn thành xử lý bằng cách gọi method <code class=\"language-text\">join</code>. Thread nơi gọi method <code class=\"language-text\">join</code> cho các thread khác, trong ví dụ trên là main thread (chương trình ban đầu chạy) sẽ bị block cho tới nhận được tín hiệu hoàn thành từ các thread kia.</p>\n<p>Bằng cách gọi <code class=\"language-text\">join</code> trên mỗi sub thread ta sẽ đảm bảo được các sub thread sẽ hoàn thành rồi mới terminate chương trình chính chạy bởi main thread.</p>\n<p>Một vài method quen thuộc khác khi làm việc với thread là sẽ được liệt kê dưới đây:</p>\n<ul>\n<li><code class=\"language-text\">Thread.current</code> - truy cập tới thread hiện tại đang thực thi logic</li>\n<li><code class=\"language-text\">Thread.list</code> - trả về danh sách các threads objects có thể chạy hoặc bị đã bị dừng.</li>\n<li>Sử dụng <code class=\"language-text\">exit</code> hoặc <code class=\"language-text\">kill</code> để dừng và terminate một thread ( <code class=\"language-text\">thread.kill()</code> )</li>\n<li>Check <code class=\"language-text\">status</code> hoặc <code class=\"language-text\">alive?</code> để kiểm tra trạng thái của một Ruby thread\n<ul>\n<li>status <strong>run</strong> - Thread đang được thực thi bình thường</li>\n<li>status <strong>sleep</strong> - Thread đang bị tạm dừng hoặc blocked</li>\n<li>status <strong>aborting</strong> - Thread đang bị kill</li>\n<li>nếu thread kết thúc bình thường sẽ trả về <strong>false</strong>, nếu bị terminate mà không lường trước được thì sẽ trả về <strong>nil</strong>.</li>\n<li><code class=\"language-text\">alive?</code> trả về true nếu status là <strong>run</strong> hoặc <strong>sleep</strong></li>\n</ul>\n</li>\n<li>Ta cũng có thể đặt ưu tiên cho một thread bằng cách set priority dùng method <code class=\"language-text\">priority=</code>, priority cao sẽ được ưu tiên chạy trước (lưu ý OS có thể phớt lờ setting này =))</li>\n</ul>\n<h3 id=\"2-sử-dụng-variables-trong-thread\" style=\"position:relative;\"><a href=\"#2-s%E1%BB%AD-d%E1%BB%A5ng-variables-trong-thread\" aria-label=\"2 sử dụng variables trong thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Sử dụng variables trong thread</h3>\n<p>Một thread có thể thoải mái sử dụng tất các các biến “trong scope nơi thread được tạo”. Những biến được tạo trong thread block code là những local variables của thread đó (thread-local variable) và sẽ không chia sẽ cho các các thread khác.</p>\n<p>Nhưng nếu ta muốn chia sẽ local variable của một thread cho các thread khác thì sao? class <code class=\"language-text\">Thread</code> có một công cụ cho phép các thread-local variables được tạo và truy cập bằng tên.</p>\n<p>Hãy xem 1 thread object là một Hash, chúng ta sẽ gán biến cho một thread bằng <code class=\"language-text\">[]=</code> và truy cập bằng <code class=\"language-text\">[]</code>. Ngoài ra ra có thể get và set các thread-local variable bằng method <code class=\"language-text\">Thread.thread_variable_get</code> và <code class=\"language-text\">Thread.thread_variable_set</code>.</p>\n<p>Để có một cái nhìn cụ thể hơn ta hãy xem qua ví dụ bên dưới</p>\n<blockquote>\n<p>Code:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">count <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nthreads <span class=\"token operator\">=</span> <span class=\"token number\">10.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>i<span class=\"token operator\">|</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n    sleep<span class=\"token punctuation\">(</span>rand<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">Thread</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">[</span><span class=\"token symbol\">:my_count</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> count <span class=\"token comment\"># gán biến my_count cho thread đang làm việc</span>\n    count <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>t<span class=\"token operator\">|</span>\n  t<span class=\"token punctuation\">.</span>join\n  print t<span class=\"token punctuation\">[</span><span class=\"token symbol\">:my_count</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string-literal\"><span class=\"token string\">\",\"</span></span>  <span class=\"token comment\"># In ra gía trị của biến my_count của thread đang làm việc</span>\n<span class=\"token keyword\">end</span>\n\nputs <span class=\"token string-literal\"><span class=\"token string\">\"count = </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">count</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span></code></pre></div>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">8, 5, 7 , 1, 4, 9, 0, 3 , 6, 2, count = 10</code></pre></div>\n<p>Ở ví dụ này có tồn tại <code class=\"language-text\">race condition</code>, đó là biến count có thể được cập nhật bởi bất kỳ thread nào. Do đó sẽ có trường hợp 2 hoặc nhiều thread hơn cập nhật giá trị tại 1 thời điểm dẫn tới kết quả không chính xác.</p>\n<p><code class=\"language-text\">race condition</code> này có để được fix bằng cách synchronization thông qua Mutual Exclusion ở phần <strong>4. Kiểm soát thread</strong></p>\n<h3 id=\"3-exception-trong-thread\" style=\"position:relative;\"><a href=\"#3-exception-trong-thread\" aria-label=\"3 exception trong thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Exception trong thread</h3>\n<p>Nếu một thread raise một exception không biết trước (không có logic handle exception này), thì việc xảy ra tiếp theo phụ thuộc vào setting của <code class=\"language-text\">Thread.abort_on_exception</code> flag và setting của interpreter <code class=\"language-text\">$DEBUG</code> flag.</p>\n<p>Nếu <code class=\"language-text\">abort_on_exception</code> là <strong>false</strong> và debug flag chưa được bật (default setting), một exception sẽ đơn giản là kill thread xảy ra exception - các phần khác vẫn chạy bình thường. Thực sự thì chúng ta sẽ không bao giờ nhận một thread exception trừ khi chúng ta dùng <code class=\"language-text\">join</code> cho thread đó. Hãy xem ví vụ này bên dưới</p>\n<blockquote>\n<p>Code: Ví dụ raise exception không dùng join</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">threads <span class=\"token operator\">=</span> <span class=\"token number\">4.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>number<span class=\"token operator\">|</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>i<span class=\"token operator\">|</span>\n    <span class=\"token keyword\">raise</span> <span class=\"token string-literal\"><span class=\"token string\">\"Boom!\"</span></span> <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n\n    p <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">i</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\npust <span class=\"token string-literal\"><span class=\"token string\">\"Waiting\"</span></span>\nsleep <span class=\"token number\">0.1</span>\nputs <span class=\"token string-literal\"><span class=\"token string\">\"Done\"</span></span></code></pre></div>\n<blockquote>\n<p>Output:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#&lt;Thread:0x00000010d6330 prog.rb:2 run> terminated with exception\n(report_on_exception is true)\nprog.rb:3:in `block (2 levels) in &lt;main>`: Boom! (RuntimeError)\nWaiting\n0\n2\n3\nDone</code></pre></div>\n<p>Thông thường chúng ta không sleep main thread để chờ các threads terminate mà chúng ta gọi join cho các threads này. If sử dụng join cho cho một thread raise exception thì exception đó sẽ được raise ở chính main thread thực hiện việc joining. Ví dụ sẽ được cập nhật một chút</p>\n<blockquote>\n<p>Code: Ví dụ raise exception có dùng join</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">threads <span class=\"token operator\">=</span> <span class=\"token number\">4.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>number<span class=\"token operator\">|</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>i<span class=\"token operator\">|</span>\n    <span class=\"token keyword\">raise</span> <span class=\"token string-literal\"><span class=\"token string\">\"Boom!\"</span></span> <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n    print <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">i</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\\n\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nputs <span class=\"token string-literal\"><span class=\"token string\">\"Waiting\"</span></span>\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>t<span class=\"token operator\">|</span>\n  <span class=\"token keyword\">begin</span>\n    t<span class=\"token punctuation\">.</span>join\n  <span class=\"token keyword\">rescue</span> RuntimeError <span class=\"token operator\">=></span> e\n    puts <span class=\"token string-literal\"><span class=\"token string\">\"Failed: </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">e<span class=\"token punctuation\">.</span>message</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nputs <span class=\"token string-literal\"><span class=\"token string\">\"Done\"</span></span></code></pre></div>\n<blockquote>\n<p>Output</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#&lt;Thread:0x0000000104591d48 prog.rb:2 run> terminated with exception\n(report_on_exception is true):\nprog.rb:3:in `block (2 levels) in &lt;main>': Boom! (RuntimeError)\nWaiting\n0\nFailed: Boom!\n2\n3\nDone</code></pre></div>\n<p><strong>Lưu ý</strong> nếu chúng ra set <code class=\"language-text\">abort_on_exception</code> là true hoặc sử dụng -d để bật Debug flag thì một exception trong thread sẽ kill main thread và message “Done” sẽ không bao giờ hiện ra.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">Thread</span><span class=\"token punctuation\">.</span>abort_on_exception <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token comment\"># ... the rest code</span></code></pre></div>\n<h3 id=\"4-kiểm-soát-thread\" style=\"position:relative;\"><a href=\"#4-ki%E1%BB%83m-so%C3%A1t-thread\" aria-label=\"4 kiểm soát thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Kiểm soát thread</h3>\n<p>Thông thường, tốt nhất là cứ để thread tự làm việc, việc lên lịch sắp xếp khi nào thread làm việc được thực thi tự động bới <code class=\"language-text\">Thread Scheduler</code>.\nTuy nhiên ta vẫn được cung cấp một số method để kiểm soát hoặc dẫn đường cho Thread Scheduler như:</p>\n<ul>\n<li><code class=\"language-text\">stop</code> - Dừng current thread</li>\n<li><code class=\"language-text\">run</code> - chạy 1 thread nào đó</li>\n<li><code class=\"language-text\">pass</code> - đưa current thread khỏi schedule để cho thread khác chạy</li>\n<li><code class=\"language-text\">join</code> và <code class=\"language-text\">value</code> - đây là 2 methods được sử dụng phổ biến và nó có tác dụng ở cho low-level thread (cấp hệ điều hành), sẽ dừng thread gọi cho tới khi các threads được gọi hoàn thành.</li>\n</ul>\n<p>Ngoài việc tương các ở mức độ low-level thread thì ta vẫn có thể thể tương tác ở mức độ higher-level thread. Hãy đi tới ví dụ bên dưới.</p>\n<blockquote>\n<p>Ví dụ 1: demo về race condition, cập nhật chung trên 1 biến</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nthreads <span class=\"token operator\">=</span> <span class=\"token number\">10.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n    <span class=\"token number\">100</span>_000<span class=\"token punctuation\">.</span>times <span class=\"token keyword\">do</span>\n      new_value <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n      puts <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">new_value</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span> <span class=\"token keyword\">if</span> new_value <span class=\"token operator\">%</span> <span class=\"token number\">200</span>_000 <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n      sum <span class=\"token operator\">=</span> new_value\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token symbol\">:join</span><span class=\"token punctuation\">)</span>\nputs <span class=\"token string-literal\"><span class=\"token string\">\"\\n sum = </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">sum</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span></code></pre></div>\n<blockquote>\n<p>Output</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">200000</span>\n<span class=\"token number\">400000</span>\n<span class=\"token number\">600000</span>\n<span class=\"token number\">800000</span>\n<span class=\"token number\">800000</span>\n<span class=\"token function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token number\">899999</span></code></pre></div>\n<p>Ở ví dụ này ta có 10 threads, mỗi thread sẽ cộng dồn vào <code class=\"language-text\">sum</code> giá trị 100,000. Khi các threads hoàn thành nếu giá trị sum cuối cùng có giá trị dưới 1,000,000 nghĩa là có race condition xảy ra (sẽ xảy ra khi 1 thread ghi đè giá trị lên sum khi 1 thread đang chờ print - print là IO action)</p>\n<p>Ta có thể tránh race condition ở ví dụ trên dễ dàng bằng cách sử dụng built-in class <code class=\"language-text\">Mutex</code> (viết tắt của “mutually exclusive”) để tạo 1 synced region - nơi mà đoạn code ở vùng này chỉ có thể được chạy bởi 1 thread tại 1 thời điểm. Nó giống như 1 toalet công cộng, mọi người đều có thể sử dụng, đôi khi ta phải xếp hàng chờ, nhưng tại một thời điểm luôn toalet sẽ bị khóa để chỉ có một người có thể sử dụng :)</p>\n<blockquote>\n<p>Ví dụ 2: cập nhật áp dụng Mutex: lock - do something - unlock</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nmutex <span class=\"token operator\">=</span> <span class=\"token builtin\">Thread</span><span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Mutex</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nthreads <span class=\"token operator\">=</span> <span class=\"token number\">10.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n    <span class=\"token number\">100</span>_000<span class=\"token punctuation\">.</span>times <span class=\"token keyword\">do</span>\n      mutex<span class=\"token punctuation\">.</span>lock               <span class=\"token comment\">## Tại một thời điểm thì khóa lại cho 1 thread sử dụng</span>\n      new_value <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> <span class=\"token number\">1</span>      <span class=\"token comment\">#</span>\n      puts <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">new_value</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span> <span class=\"token keyword\">if</span> new_value <span class=\"token operator\">%</span> <span class=\"token number\">200</span>_000 <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n      sum <span class=\"token operator\">=</span> new_value          <span class=\"token comment\">#</span>\n      mutex<span class=\"token punctuation\">.</span>unlock             <span class=\"token comment\">##</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token symbol\">:join</span><span class=\"token punctuation\">)</span>\nputs <span class=\"token string-literal\"><span class=\"token string\">\"\\nsum = </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">sum</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span></code></pre></div>\n<blockquote>\n<p>Output</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">200000</span>\n<span class=\"token number\">400000</span>\n<span class=\"token number\">600000</span>\n<span class=\"token number\">800000</span>\n<span class=\"token number\">1000000</span>\n<span class=\"token function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span></code></pre></div>\n<p>Với pattern lock - do something - unlock, ta có thể dùng một method cung cấp sẵn của <code class=\"language-text\">Mutex</code> là <code class=\"language-text\">synchronize</code>, method này còn đảm bảo mutex sẽ được unlocked nếu exception xảy ra. Nếu viết thủ công và không handle kỹ thì có thể khi exception xảy ra thì mutex sẽ không bao giờ được unlocked và các threads khác sẽ không bao giờ sử dụng được.</p>\n<blockquote>\n<p>Ví dụ 3: cập nhật dùng Mutex.synchronize</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nmutex <span class=\"token operator\">=</span> <span class=\"token builtin\">Thread</span><span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Mutex</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nthreads <span class=\"token operator\">=</span> <span class=\"token number\">10.</span>times<span class=\"token punctuation\">.</span>map <span class=\"token keyword\">do</span>\n  <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n    <span class=\"token number\">100</span>_000<span class=\"token punctuation\">.</span>times <span class=\"token keyword\">do</span>\n      mutex<span class=\"token punctuation\">.</span>synchronize <span class=\"token keyword\">do</span>       <span class=\"token comment\">## Tại một thời điểm thì khóa lại cho 1 thread sử dụng</span>\n        new_value <span class=\"token operator\">=</span> sum <span class=\"token operator\">+</span> <span class=\"token number\">1</span>      <span class=\"token comment\">#</span>\n        puts <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">new_value</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span> <span class=\"token keyword\">if</span> new_value <span class=\"token operator\">%</span> <span class=\"token number\">250</span>_000 <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n        sum <span class=\"token operator\">=</span> new_value          <span class=\"token comment\">#</span>\n      <span class=\"token keyword\">end</span>                        <span class=\"token comment\">#</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nthreads<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token symbol\">:join</span><span class=\"token punctuation\">)</span>\nputs <span class=\"token string-literal\"><span class=\"token string\">\"\\nsum = </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">sum</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span></code></pre></div>\n<blockquote>\n<p>Output</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">250000</span>\n<span class=\"token number\">500000</span>\n<span class=\"token number\">750000</span>\n<span class=\"token number\">1000000</span>\n<span class=\"token function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span></code></pre></div>\n<p>===</p>\n<p>Chúng ta đã hiểu cách sử dụng Mutex ở các trường hợp đơn giản thông qua các ví dụ trên.\nNgoài ra chúng ta còn có thể sử dụng một số method phổ biến khác như <code class=\"language-text\">try_lock</code>, method này sẽ thử lock mutex nếu có thể trả về <strong>true</strong>, nếu ko lock được sẽ trả về <strong>false</strong>. Chúng ta sẽ đi qua thêm một ví dụ cho method này.</p>\n<blockquote>\n<p>Ví dụ sử dụng <code class=\"language-text\">try_lock</code></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">rate_mutex <span class=\"token operator\">=</span> <span class=\"token builtin\">Thread</span><span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Mutex</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nexchange_rates <span class=\"token operator\">=</span> <span class=\"token class-name\">ExchangeRates</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nexchange_rates<span class=\"token punctuation\">.</span>update_from_online_feed\n\n<span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n  loop <span class=\"token keyword\">do</span>\n    sleep <span class=\"token number\">3600</span>                                    <span class=\"token comment\"># Cứ mỗi 1h thì thức dậy, lock lại và cập nhật exchange rate</span>\n    rate_mutex<span class=\"token punctuation\">.</span>synchronize <span class=\"token keyword\">do</span>                     <span class=\"token comment\">#</span>\n      exchange_rates<span class=\"token punctuation\">.</span>update_from_online_feed      <span class=\"token comment\">#</span>\n    <span class=\"token keyword\">end</span>                                           <span class=\"token comment\">#</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nloop <span class=\"token keyword\">do</span>\n  puts <span class=\"token string-literal\"><span class=\"token string\">\"Enter currency code and amount:\"</span></span>\n  line <span class=\"token operator\">=</span> gets\n\n  <span class=\"token keyword\">if</span> rate_mutex<span class=\"token punctuation\">.</span>try_lock                                              <span class=\"token comment\"># Cố gắng thử lock để lấy quyền sử dụng exchange rate</span>\n    puts<span class=\"token punctuation\">(</span>exchange_rates<span class=\"token punctuation\">.</span>convert<span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ensure</span> rate_mutex<span class=\"token punctuation\">.</span>unlock       <span class=\"token comment\"># Hiển thị rate, nếu có exception thì đảm bảo unlock</span>\n  <span class=\"token keyword\">else</span>\n    puts <span class=\"token string-literal\"><span class=\"token string\">\"Sorry, rates being updated. Try again in a minute\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Trong trường hợp chúng ta đang giữ một lock của một mutex mà muốn unlock tạm thời (trong một khoảng thời gian) để cho phép những threads khác sử dụng, có có thể sử dụng <code class=\"language-text\">Mutex#sleep</code></p>\n<blockquote>\n<p>Ví dụ sử dụng <code class=\"language-text\">sleep</code></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">rate_mutex <span class=\"token operator\">=</span> <span class=\"token builtin\">Thread</span><span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Mutex</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nexchange_rates <span class=\"token operator\">=</span> <span class=\"token class-name\">ExchangeRates</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nexchange_rates<span class=\"token punctuation\">.</span>update_from_online_feed\n\n<span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n  rate_mutex<span class=\"token punctuation\">.</span>lock\n  loop <span class=\"token keyword\">do</span>\n    rate_mutex<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">3600</span><span class=\"token punctuation\">)</span>                                           <span class=\"token comment\"># Tạm thời unlock resource trong 3600s sau đó sẽ lock lại</span>\n    exchange_rates<span class=\"token punctuation\">.</span>update_from_online_feed\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nloop <span class=\"token keyword\">do</span>\n  puts <span class=\"token string-literal\"><span class=\"token string\">\"Enter currency code and amount:\"</span></span>\n  line <span class=\"token operator\">=</span> gets\n\n  <span class=\"token keyword\">if</span> rate_mutex<span class=\"token punctuation\">.</span>try_lock                                             <span class=\"token comment\"># Cố gắng thử lock để lấy quyền sử dụng exchange rate</span>\n    puts<span class=\"token punctuation\">(</span>exchange_rates<span class=\"token punctuation\">.</span>convert<span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">ensure</span> rate_mutex<span class=\"token punctuation\">.</span>unlock      <span class=\"token comment\"># Hiển thị rate, nếu có exception thì đảm bảo unlock</span>\n  <span class=\"token keyword\">else</span>\n    puts <span class=\"token string-literal\"><span class=\"token string\">\"Sorry, rates being updated. Try again in a minute\"</span></span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<h2 id=\"iii-làm-việc-ở-cấp-độ-process\" style=\"position:relative;\"><a href=\"#iii-l%C3%A0m-vi%E1%BB%87c-%E1%BB%9F-c%E1%BA%A5p-%C4%91%E1%BB%99-process\" aria-label=\"iii làm việc ở cấp độ process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>III. Làm việc ở cấp độ Process</h2>\n<p>Đôi khi chúng ta cần chia task ra và thực hiện ở một vài process khác nhau để có thể tận dụng ưu điểm của multiple cores/cpus hoặc chạy 1 process riêng ko được viết bằng Ruby (C++, Golang …)</p>\n<p>Ruby vẫn hỗ trợ cũng ta một số methods để sinh ra và quản lý các processes khác từ process chính.</p>\n<h3 id=\"1-sinh-ra-một-process-mới\" style=\"position:relative;\"><a href=\"#1-sinh-ra-m%E1%BB%99t-process-m%E1%BB%9Bi\" aria-label=\"1 sinh ra một process mới permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Sinh ra một process mới</h3>\n<h3 id=\"2-process-con-chạy-độc-lập\" style=\"position:relative;\"><a href=\"#2-process-con-ch%E1%BA%A1y-%C4%91%E1%BB%99c-l%E1%BA%ADp\" aria-label=\"2 process con chạy độc lập permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Process con chạy độc lập</h3>\n<h3 id=\"3-block-code-và-subprocesses\" style=\"position:relative;\"><a href=\"#3-block-code-v%C3%A0-subprocesses\" aria-label=\"3 block code và subprocesses permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Block code và Subprocesses</h3>\n<h2 id=\"iv-fiber-là-một-lightweight-thread\" style=\"position:relative;\"><a href=\"#iv-fiber-l%C3%A0-m%E1%BB%99t-lightweight-thread\" aria-label=\"iv fiber là một lightweight thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IV. Fiber là một lightweight thread?</h2>\n<p>Cái tên Fiber khiến mọi người có thể nhầm lẫn và xem nó như 1 loại “lightweight-thread” của Ruby, nhưng bản chất Ruby Fiber là một code block chứ không phải một thread, điều đặc biệt là “block of code” này có thể stop và restart có thể xem nó là <strong>coroutine</strong>.</p>\n<p>Fibers trong Ruby được sử dụng cho “cooperatively multitasking”, mỗi fiber sẽ giải quyết một phần công việc bằng cách phối hợp, tương tác với fibers hoặc code khác, khác với thread thường ưu tiên để làm các công việc song song ko ràng buộc nhau, một điều khác biệt rõ ràng nữa của Fiber so với Thread là chính chúng ra phải control việc chạy các fibers này thay vì để OS (hệ điều hành quyết định) như thread.</p>\n<p><strong>Fiber không chạy ngay lập tức khi được tạo, sẽ hoạt động kiểu dừng - chạy - dừng</strong></p>\n<blockquote>\n<p>Ví dụ: Đếm số lần xuất hiện của các từ</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">counts <span class=\"token operator\">=</span> <span class=\"token class-name\">Hash</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">File</span><span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"./testfile\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>line<span class=\"token operator\">|</span>\n  line<span class=\"token punctuation\">.</span>scan<span class=\"token punctuation\">(</span><span class=\"token regex-literal\"><span class=\"token regex\">/\\w+/</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>word<span class=\"token operator\">|</span>\n    word <span class=\"token operator\">=</span> word<span class=\"token punctuation\">.</span>downcase\n    counts<span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\ncounts<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>k<span class=\"token operator\">|</span> print <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">k</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">:</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">counts<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span></span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\"> \"</span></span> <span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Output</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1</code></pre></div>\n<p>Ví dụ ở trên vẫn chạy ổn, chỉ có điều là logic tìm word và logic đếm word trộn lẫn với nhau. Ví dụ dưới đây sử dụng Fiber để tách biệt logic</p>\n<blockquote>\n<p>Ví dụ: Đếm số lần xuất hiện của các từ dùng Fiber</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">words <span class=\"token operator\">=</span> <span class=\"token class-name\">Fiber</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>                      <span class=\"token comment\">#</span>\n  <span class=\"token builtin\">File</span><span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"./testfile\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>line<span class=\"token operator\">|</span>    <span class=\"token comment\">#</span>\n    line<span class=\"token punctuation\">.</span>scan<span class=\"token punctuation\">(</span><span class=\"token regex-literal\"><span class=\"token regex\">/\\w+/</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>word<span class=\"token operator\">|</span>            <span class=\"token comment\">#</span>\n      Fiber<span class=\"token punctuation\">.</span><span class=\"token keyword\">yield</span> word<span class=\"token punctuation\">.</span>downcase           <span class=\"token comment\"># Dừng chạy code cho tới khi resume được gọi, khi resume gọi sẽ nhận về giá trị được passed</span>\n    <span class=\"token keyword\">end</span>                                   <span class=\"token comment\"># trong Fiber.yield</span>\n  <span class=\"token keyword\">end</span>                                     <span class=\"token comment\">#</span>\n  <span class=\"token keyword\">nil</span>                                     <span class=\"token comment\">#</span>\n<span class=\"token keyword\">end</span>\n\ncounts <span class=\"token operator\">=</span> <span class=\"token class-name\">Hash</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>word <span class=\"token operator\">=</span> words<span class=\"token punctuation\">.</span>resume<span class=\"token punctuation\">)</span>             <span class=\"token comment\"># Gọi lần đầu sẽ chạy code trong fiber cho tới khi gặp Fiber.yield và nhận giá trị được passed</span>\n  counts<span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>                     <span class=\"token comment\"># trong Fiber.yield, các lần sau sẽ tiếp tục như vậy</span>\n<span class=\"token keyword\">end</span>\n\ncounts<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>k<span class=\"token operator\">|</span> print <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">k</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">:</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">counts<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span></span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\"> \"</span></span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Cấu trúc của Fiber là sẽ nhận 1 code block và trả về 1 fiber object. Không giống thread, code trong block của một fiber không chạy một lèo ngay lập tức. Sau khi một fiber được tạo, chúng ta có thể gọi <code class=\"language-text\">resume</code> trên fiber object đó. Gọi <code class=\"language-text\">resume</code> lần đầu thì block code trong fiber mới được thực khi.</p>\n<p>Ở ví dụ trên,</p>\n<ul>\n<li>File <em>testfile</em> được open và chúng ta bắt đầu scan để lấy ra từng từ đơn lẻ và pass vào scan block.</li>\n<li>Trong block này, <code class=\"language-text\">Fiber.yield</code> được gọi, việc gọi <code class=\"language-text\">Fiber.yield</code> sẽ dừng việc thực thi code trong fiber tới khi <code class=\"language-text\">resume</code> được gọi</li>\n<li>Khi ta gọi <code class=\"language-text\">resume</code> từ fiber object, sẽ nhận về  giá trị được passed vào trong Fiber.yield và code tiếp tục chạy tới khi gặp Fiber.yield</li>\n<li>Cứ tiếp tục như vậy cho tới khi chạy hết logic trong fiber và vòng loop kết thúc.</li>\n</ul>\n<blockquote>\n<p>Ví dụ: Tạo số tuần tự chẵn vô tận, không chia hết cho 3</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">sequence_number <span class=\"token operator\">=</span> <span class=\"token class-name\">Fiber</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">do</span>\n  num <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n  loop <span class=\"token keyword\">do</span>\n    Fiber<span class=\"token punctuation\">.</span><span class=\"token keyword\">yield</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token keyword\">unless</span> num <span class=\"token operator\">%</span> <span class=\"token number\">3</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n    num <span class=\"token operator\">+=</span> <span class=\"token number\">2</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token number\">10.</span>times <span class=\"token punctuation\">{</span> puts sequence_number<span class=\"token punctuation\">.</span>resume <span class=\"token punctuation\">}</span></code></pre></div>\n<p>===</p>\n<p>Fibers chỉ là các objects, chúng ta có thể pass hoặc store như các biến nhưng lưu ý là Fiber chỉ có thể được <code class=\"language-text\">resume</code> trong chính thread tạo ra nó.\nChúng ta có thể sử dụng <code class=\"language-text\">transfer</code> thay thế cho bộ đôi <code class=\"language-text\">yield/resume</code>, nhưng sẽ phức tạp hơn.\nNgoài ra thì còn có non-blocking fibers, các fibers sẽ được quản lý bởi fiber scheduler.</p>\n<h2 id=\"v-hiểu-về-ractor\" style=\"position:relative;\"><a href=\"#v-hi%E1%BB%83u-v%E1%BB%81-ractor\" aria-label=\"v hiểu về ractor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V. Hiểu về Ractor</h2>\n<p>Rator vẫn chỉ là bản thử nghiệm (tính tới Ruby 3.2), chưa phải là chức năng chính thức.</p>\n<p>Ractor cho phép chạy <strong>true parallelism</strong> trong một Ruby interpreter đơn: mỗi Ractor có một GIL riêng biệt, để xử lý concurrent tốt hơn.</p>\n<h3 id=\"1-cách-ractor-hoạt-động\" style=\"position:relative;\"><a href=\"#1-c%C3%A1ch-ractor-ho%E1%BA%A1t-%C4%91%E1%BB%99ng\" aria-label=\"1 cách ractor hoạt động permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Cách Ractor hoạt động</h3>\n<p>Ractors cho phép <strong>true parallelism</strong> trong một Ruby interpreter tách biệt: mỗi Ractor duy trì một GIL riêng, để đảm bảo performance tốt hơn. Để đảm bảo điều này thì việc truy cập các variables các biến bên ngoài scope của ractor bị giới hạn và việc giao tiếp giữa các ractors cũng chỉ được thực việc với một vài cách hạn chế.</p>\n<p>Bạn có thể hiểu 1 ractor sẽ là 1 căn phòng (chứa code) với duy nhất 1 cửa vào “entrance” và 1 cửa ra “exit”. Và chúng ta có thể phải xếp hàng ở cửa vào trong một số trường hợp.</p>\n<p>Tạo ra một ractor bằng <code class=\"language-text\">Ractor.new</code>, sẽ luôn luôn nhận 1 block code, đây sẽ là đoạn code nằm trong căn phòng của chúng ta. Ngoài ra thì <code class=\"language-text\">Ractor.new</code> còn nhận thêm một vài tham số khác, nhưng <code class=\"language-text\">name</code> - unique name của Ractor.</p>\n<p>Một khi một ractor được tạo ra, thread tạo ra ractor đó sẽ được gọi là <code class=\"language-text\">main</code> ractor và có thể được truy cập thông qua <code class=\"language-text\">Ractor.main</code></p>\n<p>Các Ractors tương tác nhau bằng 1 trong 4 cách sau:</p>\n<ul>\n<li>Một Ractor (bao gồm main thread) có thể gửi các arguments tới 1 Ractor được biết trước đó (thông qua unique name …) Nói một cách ẩn dụ, thì tương ứng với việc yêu cầu ai đó đứng trước hàng chờ của một cửa vào “entrance” của một căn phòng khác. Có một điều cần lưu ý là hàng chờ này là vô hạn (ko có giới hạn con số) và sau khi gửi thì ta <em>không bị blocked để chờ phản hồi</em>. Chúng ta dùng API <code class=\"language-text\">send</code> để gửi message từ một ractor đến một ractor khác.</li>\n<li>Một Ractor (hoặc main thread) có thể nhận output từ một Ractor được biết trước đó. Nói một cách ẩn dụng, chúng ta lần này sẽ đợi ở cửa ra “exit” để chờ lấy món đồ tiếp theo xuất hiện và lấy nó đi. Dùng API <code class=\"language-text\">take</code> để một ractor chờ nhận giá trị trả về của một ractor khác (api này sẽ block waiting)</li>\n<li>Bên trong một ractor, ractor có thể block waiting để chờ nhận một message sắp tới. Hiểu ẩn dụ là ta sẽ chờ ai đó xuất hiện và gõ cửa vào “entrance”. Ta dùng API <code class=\"language-text\">Ractor.receive</code> - Class method, để chờ message ở cửa vào (api này sẽ block waiting)</li>\n<li>Trường hợp cuối cùng là bên trong một ractor, có thể block waiting chờ yêu cầu của một ractor khác. Chờ ai đó gõ cửa “Exit” để yêu cần nhận đồ. Ta dùng API <code class=\"language-text\">Ractor.yield(obj)</code>, argument truyền vào là món đồ/message được gửi đi.</li>\n</ul>\n<p>Vòng đời của một ractor như sau:</p>\n<ul>\n<li>Đầu tiên, ractor được tạo bằng cách sử dụng <code class=\"language-text\">Ractor.new</code>. Code block de được truyền vào start ngay lập tức, các arguments được passed tới <code class=\"language-text\">new</code> sẽ được pass tới tới block code.</li>\n<li>Ractor được tạo ra thì <em>biệt lập hoàn toàn - isolated</em>, nghĩa là nó không thể truy cập được bất cứ thứ gì không được định nghĩa bên trong code block, không có globals, không có external locals. Chỉ có duy nhất 1 các để đưa value vào một ractor là thông qua method <code class=\"language-text\">send</code></li>\n<li>Code block đưa vào ractor sẽ thực thi cho đến khi:\n<ul>\n<li>Code block gặp <code class=\"language-text\">Ractor.yield</code> call, trường hợp này nó sẽ đợi một ractor khác gọi <code class=\"language-text\">take</code>, khi ractor khác gọi <code class=\"language-text\">take</code> thì ngay lập tức sẽ pass argument trong <code class=\"language-text\">yield()</code> và tiếp tục chạy tiếp.</li>\n<li>Code block gặp <code class=\"language-text\">Ractor.receive</code> call, nó sẽ đợi cho một ractor khác gọi <code class=\"language-text\">send</code>, arguments được gửi bởi <code class=\"language-text\">send</code> là giá trị trả về của <code class=\"language-text\">Ractor.receive</code></li>\n<li>Code block kết thúc. Giá trị của expression cuối cùng sẽ gửi cho ractor nào dùng <code class=\"language-text\">take</code> để nhận.</li>\n</ul>\n</li>\n</ul>\n<p>Tiếp theo hãy quay lại bằng toán đếm từ</p>\n<blockquote>\n<p>Ví dụ: Đếm từ bằng Ractor</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">reader <span class=\"token operator\">=</span> <span class=\"token class-name\">Ractor</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token symbol\">name</span><span class=\"token operator\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"reader\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n  <span class=\"token builtin\">File</span><span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"testfile\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>line<span class=\"token operator\">|</span>\n    line<span class=\"token punctuation\">.</span>scan<span class=\"token punctuation\">(</span><span class=\"token regex-literal\"><span class=\"token regex\">/\\w+/</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>word<span class=\"token operator\">|</span>\n      Ractor<span class=\"token punctuation\">.</span><span class=\"token keyword\">yield</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">.</span>downcase<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">nil</span> <span class=\"token comment\"># Giá trị expression cuối cùng của code block</span>\n<span class=\"token keyword\">end</span>\n\ncounter <span class=\"token operator\">=</span> <span class=\"token class-name\">Ractor</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">,</span> <span class=\"token symbol\">name</span><span class=\"token operator\">:</span> <span class=\"token string-literal\"><span class=\"token string\">\"counter\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>source<span class=\"token operator\">|</span>\n  result <span class=\"token operator\">=</span> <span class=\"token class-name\">Hash</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>word <span class=\"token operator\">=</span> source<span class=\"token punctuation\">.</span>take<span class=\"token punctuation\">)</span>\n    result<span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n  <span class=\"token keyword\">end</span>\n  result\n<span class=\"token keyword\">end</span>\n\ncounts <span class=\"token operator\">=</span> counter<span class=\"token punctuation\">.</span>take\ncounts<span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>word<span class=\"token operator\">|</span> p <span class=\"token string-literal\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">word</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">:</span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">counts<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span></span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"2-truyền-variable-vào-ractor\" style=\"position:relative;\"><a href=\"#2-truy%E1%BB%81n-variable-v%C3%A0o-ractor\" aria-label=\"2 truyền variable vào ractor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Truyền Variable vào Ractor</h3>","frontmatter":{"title":"Đa tác vụ trong Ruby - Gửi lời chào tới Thread, Fiber và Ractor","date":"December 14, 2022","description":"Cách sử lý multi-tasking trong Ruby bằng các sử dụng Thread, Fiber và Ractor"}},"previous":{"fields":{"slug":"/2022-12-06-using-interractors-as-work-action-chains/"},"frontmatter":{"title":"Sử dụng gem Interactor để xây dựng các actions có tính tái sử dụng cao"}},"next":{"fields":{"slug":"/2023-01-01-sql-antipatterns-jaywalking-01/"},"frontmatter":{"title":"SQL Antipatterns - Jaywalking (01)"}}},"pageContext":{"id":"65803d60-a7de-5ead-ad26-074b28c70b17","previousPostId":"1c83713c-d045-5103-88f3-5d0b5eea8be1","nextPostId":"9581d8b2-0d4a-570f-9311-7647960d17cc"}},"staticQueryHashes":["230163734","2841359383"],"slicesMap":{}}